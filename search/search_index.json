{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scholar's tools for arXiv","text":"<p>The <code>sxolar</code> package is a collection of tools for working with arXiv data. It includes low-level and high-level interfaces for querying arXiv metadata, summarizing query results into digest formats, and optional control based on a configuration file.</p> <p>The tools are written in Python and are designed to be used in any python application. A command line interface is also provided for easy access to the tools from a shell. The core tools are designed to be used in place of the <code>Arxiv API &lt;https://arxiv.org/help/api/index&gt;</code>,  with a simpler interface and more features, including</p> <ul> <li>Searching and filtering papers</li> <li>Creating personalized search summaries </li> <li>Persisting useful searches for automated search digests</li> </ul> <p>Ultimately, the goal of this project is to provide a set of tools that can be used to build a personalized search engine for academic papers, with the ability to search, download, and explore the network of citations between papers.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install sXolar, run the command:</p> <pre><code>pip install sxolar\n</code></pre> <p>This will install the sXolar package and all of its dependencies.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>The high-level api provides a simple object-oriented interface for constructing and executing queries. Here is an example of how to use the high-level api:</p> <pre><code>from sxolar import Author\n\nquery = Author('John Doe') | Author('Jane Doe')\nquery.search()\n</code></pre> <p>Note that some builtin python operations have been overloaded to provide a more intuitive interface for constructing queries. For example, the <code>|</code> operator is overloaded to represent a logical OR operation between two query objects. For more information on the high-level api, see the API Docs.</p>"},{"location":"#quick-examples","title":"Quick Examples","text":"<p>Here are some quick examples of how to use the sXolar package.</p> <p>Search for papers by a specific author:</p> <pre><code>from sxolar import Author\n\nquery = Author('John Doe')\nquery.search()\n</code></pre> <p>Search for papers by multiple authors (logical OR):</p> <pre><code>from sxolar import Author\n\nquery = Author('John Doe') | Author('Jane Doe')\nquery.search()\n</code></pre> <p>Search for papers by a specific title:</p> <pre><code>from sxolar import Title\n\nquery = Title(\"Quantum Mechanics\")\nquery.search()\n</code></pre> <p>Search for papers with a specific title, but not by a specific author:</p> <pre><code>from sxolar import Title, Author\n\nquery = Title('Quantum Mechanics') - Author('John Doe')\nquery.search()\n</code></pre> <p>Search for papers with a specific title, but not by a specific set of authors:</p> <pre><code>from sxolar import Title, Author\n\nquery = Title('Quantum Mechanics') - (Author('John Doe') | Author('Jane Doe')).wrap()\nquery.search()\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Thank you to arXiv for use of its open access interoperability.</p>"},{"location":"api/","title":"Sxolar API Documentation","text":"<p>The <code>sxolar</code> package provides a simple interface to search for papers on the arXiv. The package is designed to be simple and intuitive to use, and is built on top of the <code>arxiv</code> package.</p> <p>The package provides two main classes: <code>Author</code> and <code>Title</code>. These classes can be used to search for papers by author or by title, respectively. The package also provides a <code>Query</code> class, which can be used to combine multiple search criteria.</p>"},{"location":"api/#sxolar-arxiv-api","title":"Sxolar ArXiv API","text":"<ul> <li>Low-level ArXiv wrappers</li> <li>High-level Interface</li> </ul>"},{"location":"api/#sxolar-utilities","title":"Sxolar Utilities","text":"<ul> <li>Google Mail Sending Utilities</li> </ul>"},{"location":"api/api/arxiv/","title":"Low-Level Interface","text":""},{"location":"api/api/arxiv/#sxolar.api.arxiv","title":"<code>sxolar.api.arxiv</code>","text":"<p>Arxiv API wrappers for sxolar, low-level functions for querying the Arxiv API. For more user-friendly functions, see the <code>sxolar.api.query</code> module.</p> References <p>[1] API Basics: https://info.arxiv.org/help/api/basics.html [2] Rate Limits: https://info.arxiv.org/help/api/tou.html [3] Search Query Language: https://info.arxiv.org/help/api/user-manual.html     #query_details [4] Entry output format: https://info.arxiv.org/help/api/user-manual.html     #_entry_metadata [5] ArXiv identifier format: https://info.arxiv.org/help/arxiv_identifier.html</p>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Author","title":"<code>Author</code>  <code>dataclass</code>","text":"<p>A dataclass for an author of an Arxiv entry.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str, the name of the author.</p> required <code>affiliation</code> <code>str</code> <p>str, the affiliation of the author.</p> required Source code in <code>sxolar/api/arxiv.py</code> <pre><code>@dataclass\nclass Author:\n    \"\"\"A dataclass for an author of an Arxiv entry.\n\n    Args:\n        name:\n            str, the name of the author.\n        affiliation:\n            str, the affiliation of the author.\n    \"\"\"\n\n    name: str\n    affiliation: str\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the author as a string.\"\"\"\n        return self.name\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Author.__str__","title":"<code>__str__()</code>","text":"<p>Return the author as a string.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the author as a string.\"\"\"\n    return self.name\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Entry","title":"<code>Entry</code>  <code>dataclass</code>","text":"<p>A dataclass for an entry from the Arxiv API [4]</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>str, the title of the entry</p> required <code>id</code> <code>Identifier</code> <p>str, the Arxiv ID of the entry</p> required <code>published</code> <code>datetime</code> <p>datetime.datetime, the published date of the entry</p> required <code>updated</code> <code>datetime</code> <p>datetime.datetime, the updated date of the entry</p> required <code>summary</code> <code>str</code> <p>str, the summary of the entry</p> required <code>author</code> <code>List[Author]</code> <p>List[Author], the authors of the entry</p> required <code>category</code> <code>List[Category]</code> <p>List[Category], the categories of the entry</p> required Source code in <code>sxolar/api/arxiv.py</code> <pre><code>@dataclass\nclass Entry:\n    \"\"\"A dataclass for an entry from the Arxiv API [4]\n\n    Args:\n        title:\n            str, the title of the entry\n        id:\n            str, the Arxiv ID of the entry\n        published:\n            datetime.datetime, the published date of the entry\n        updated:\n            datetime.datetime, the updated date of the entry\n        summary:\n            str, the summary of the entry\n        author:\n            List[Author], the authors of the entry\n        category:\n            List[Category], the categories of the entry\n    \"\"\"\n\n    title: str\n    id: Identifier\n    published: datetime.datetime\n    updated: datetime.datetime\n    summary: str\n    author: List[Author]\n    category: List[Category]\n\n    def link(self) -&gt; str:\n        \"\"\"Formatted arxiv link for the entry\"\"\"\n        return f\"https://arxiv.org/abs/{self.id}\"\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Return the entry as a dictionary.\"\"\"\n        return {\n            FIELD_ENTRY_TITLE: self.title,\n            FIELD_ENTRY_ID: self.id,\n            FIELD_ENTRY_PUBLISHED: self.published,\n            FIELD_ENTRY_UPDATED: self.updated,\n            FIELD_ENTRY_SUMMARY: self.summary,\n            FIELD_ENTRY_AUTHOR: self.author,\n            FIELD_ENTRY_CATEGORY: self.category,\n        }\n\n    @staticmethod\n    def from_dict(data: dict) -&gt; \"Entry\":\n        \"\"\"Create an entry from a dictionary.\"\"\"\n        return Entry(\n            title=data[FIELD_ENTRY_TITLE],\n            id=data[FIELD_ENTRY_ID],\n            published=data[FIELD_ENTRY_PUBLISHED],\n            updated=data[FIELD_ENTRY_UPDATED],\n            summary=data[FIELD_ENTRY_SUMMARY],\n            author=data[FIELD_ENTRY_AUTHOR],\n            category=data[FIELD_ENTRY_CATEGORY],\n        )\n\n    def filter_authors(self, authors: List[str]) -&gt; bool:\n        \"\"\"Check if the entry has any of the given authors.\n\n        Args:\n            authors:\n                List[str], the list of authors to check for.\n\n        Returns:\n            bool: True if the entry has any of the authors, False otherwise.\n        \"\"\"\n        lower_authors = [author.lower().strip() for author in authors]\n        return any(author.name.lower().strip() in lower_authors for author in self.author)\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Entry.filter_authors","title":"<code>filter_authors(authors)</code>","text":"<p>Check if the entry has any of the given authors.</p> <p>Parameters:</p> Name Type Description Default <code>authors</code> <code>List[str]</code> <p>List[str], the list of authors to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the entry has any of the authors, False otherwise.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def filter_authors(self, authors: List[str]) -&gt; bool:\n    \"\"\"Check if the entry has any of the given authors.\n\n    Args:\n        authors:\n            List[str], the list of authors to check for.\n\n    Returns:\n        bool: True if the entry has any of the authors, False otherwise.\n    \"\"\"\n    lower_authors = [author.lower().strip() for author in authors]\n    return any(author.name.lower().strip() in lower_authors for author in self.author)\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Entry.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Create an entry from a dictionary.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>@staticmethod\ndef from_dict(data: dict) -&gt; \"Entry\":\n    \"\"\"Create an entry from a dictionary.\"\"\"\n    return Entry(\n        title=data[FIELD_ENTRY_TITLE],\n        id=data[FIELD_ENTRY_ID],\n        published=data[FIELD_ENTRY_PUBLISHED],\n        updated=data[FIELD_ENTRY_UPDATED],\n        summary=data[FIELD_ENTRY_SUMMARY],\n        author=data[FIELD_ENTRY_AUTHOR],\n        category=data[FIELD_ENTRY_CATEGORY],\n    )\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Entry.link","title":"<code>link()</code>","text":"<p>Formatted arxiv link for the entry</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def link(self) -&gt; str:\n    \"\"\"Formatted arxiv link for the entry\"\"\"\n    return f\"https://arxiv.org/abs/{self.id}\"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Entry.to_dict","title":"<code>to_dict()</code>","text":"<p>Return the entry as a dictionary.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Return the entry as a dictionary.\"\"\"\n    return {\n        FIELD_ENTRY_TITLE: self.title,\n        FIELD_ENTRY_ID: self.id,\n        FIELD_ENTRY_PUBLISHED: self.published,\n        FIELD_ENTRY_UPDATED: self.updated,\n        FIELD_ENTRY_SUMMARY: self.summary,\n        FIELD_ENTRY_AUTHOR: self.author,\n        FIELD_ENTRY_CATEGORY: self.category,\n    }\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Identifier","title":"<code>Identifier</code>  <code>dataclass</code>","text":"<p>A dataclass for an Arxiv identifier.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>str</code> <p>str, the number of the identifier.</p> required <code>version</code> <code>str</code> <p>str, the version of the identifier.</p> required <code>is_new</code> <code>bool</code> <p>bool, whether the identifier is in the new format.</p> required Source code in <code>sxolar/api/arxiv.py</code> <pre><code>@dataclass\nclass Identifier:\n    \"\"\"A dataclass for an Arxiv identifier.\n\n    Args:\n        number:\n            str, the number of the identifier.\n        version:\n            str, the version of the identifier.\n        is_new:\n            bool, whether the identifier is in the new format.\n    \"\"\"\n\n    number: str\n    version: str\n    is_new: bool\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the identifier as a string.\"\"\"\n        if self.is_new:\n            return f\"{self.number}v{self.version}\" if self.version else self.number\n        return self.number\n\n    def link(self) -&gt; str:\n        \"\"\"Formatted arxiv link for the identifier\"\"\"\n        return f\"{ID_PREFIX}{self}\"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Identifier.__str__","title":"<code>__str__()</code>","text":"<p>Return the identifier as a string.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the identifier as a string.\"\"\"\n    if self.is_new:\n        return f\"{self.number}v{self.version}\" if self.version else self.number\n    return self.number\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.Identifier.link","title":"<code>link()</code>","text":"<p>Formatted arxiv link for the identifier</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def link(self) -&gt; str:\n    \"\"\"Formatted arxiv link for the identifier\"\"\"\n    return f\"{ID_PREFIX}{self}\"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.LogicalOperator","title":"<code>LogicalOperator</code>","text":"<p>Enumeration of logical operators for the Arxiv API [3]</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>class LogicalOperator:\n    \"\"\"Enumeration of logical operators for the Arxiv API [3]\"\"\"\n\n    AND = \" AND \"\n    OR = \" OR \"\n    AND_NOT = \" ANDNOT \"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.SearchField","title":"<code>SearchField</code>","text":"<p>Enumeration of search fields for the Arxiv API [3]</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>class SearchField:\n    \"\"\"Enumeration of search fields for the Arxiv API [3]\"\"\"\n\n    TITLE = \"ti\"\n    AUTHOR = \"au\"\n    ABSTRACT = \"abs\"\n    COMMENT = \"co\"\n    JOURNAL_REFERENCE = \"jr\"\n    CATEGORY = \"cat\"\n    REPORT_NUMBER = \"rn\"\n    ID = \"id\"\n    ALL = \"all\"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.SortBy","title":"<code>SortBy</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of sort fields for the Arxiv API [3]</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>class SortBy(str, enum.Enum):\n    \"\"\"Enumeration of sort fields for the Arxiv API [3]\"\"\"\n\n    Relevance = \"relevance\"\n    LastUpdatedDate = \"lastUpdatedDate\"\n    SubmittedDate = \"submittedDate\"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.SortOrder","title":"<code>SortOrder</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Enumeration of sort orders for the Arxiv API [3]</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>class SortOrder(str, enum.Enum):\n    \"\"\"Enumeration of sort orders for the Arxiv API [3]\"\"\"\n\n    Ascending = \"ascending\"\n    Descending = \"descending\"\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.execute","title":"<code>execute(search_query=None, id_list=None, start=0, max_results=10, sort_by=SortBy.Relevance, sort_order=SortOrder.Descending, min_date=None, max_date=None, date_filter_field=FIELD_ENTRY_UPDATED)</code>","text":"<p>Query the Arxiv API with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>search_query</code> <code>str</code> <p>str, optional, The query string to search for. Defaults to None.</p> <code>None</code> <code>id_list</code> <code>List[str]</code> <p>List[str], optional, A list of Arxiv IDs to search for. Defaults to None.</p> <code>None</code> <code>start</code> <code>int</code> <p>int, optional, The index to start the search from. Defaults to 0.</p> <code>0</code> <code>max_results</code> <code>int</code> <p>int, optional, The maximum number of results to return. Defaults to 10.</p> <code>10</code> <code>sort_by</code> <code>SortBy</code> <p>SortBy, optional, The field to sort by. Defaults to SortBy.Relevance.</p> <code>Relevance</code> <code>sort_order</code> <code>SortOrder</code> <p>SortOrder, optional, The order to sort by. Defaults to SortOrder.Descending.</p> <code>Descending</code> <p>Returns:</p> Type Description <code>List[Entry]</code> <p>List[Entry]: The list of entries returned by the query.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def execute(\n    search_query: str = None,\n    id_list: List[str] = None,\n    start: int = 0,\n    max_results: int = 10,\n    sort_by: SortBy = SortBy.Relevance,\n    sort_order: SortOrder = SortOrder.Descending,\n    min_date: datetime.datetime = None,\n    max_date: datetime.datetime = None,\n    date_filter_field: str = FIELD_ENTRY_UPDATED,\n\n) -&gt; List[Entry]:\n    \"\"\"Query the Arxiv API with the given parameters.\n\n    Args:\n        search_query:\n            str, optional, The query string to search for. Defaults to None.\n        id_list:\n            List[str], optional, A list of Arxiv IDs to search for. Defaults to None.\n        start:\n            int, optional, The index to start the search from. Defaults to 0.\n        max_results:\n            int, optional, The maximum number of results to return. Defaults to 10.\n        sort_by:\n            SortBy, optional, The field to sort by. Defaults to SortBy.Relevance.\n        sort_order:\n            SortOrder, optional, The order to sort by. Defaults to SortOrder.Descending.\n\n    Returns:\n        List[Entry]: The list of entries returned by the query.\n    \"\"\"\n    # Define the parameters for the query\n    params = {\n        \"search_query\": search_query,\n        \"id_list\": id_list,\n        \"start\": start,\n        \"max_results\": max_results,\n        \"sortBy\": sort_by.value,\n        \"sortOrder\": sort_order.value,\n    }\n\n    # Filter out the None values\n    params = {k: v for k, v in params.items() if v is not None}\n\n    # Get and parse the response\n    results = get_and_parse(URL_QUERY, params)\n\n    # Filter for dates if specified\n    if date_filter_field not in (FIELD_ENTRY_PUBLISHED, FIELD_ENTRY_UPDATED):\n        raise ValueError(\n            f\"Invalid date filter field: {date_filter_field}, options \"\n            f\"are {FIELD_ENTRY_PUBLISHED} or {FIELD_ENTRY_UPDATED}\"\n        )\n    if min_date is not None:\n        results = [r for r in results if getattr(r, date_filter_field) &gt;= min_date]\n    if max_date is not None:\n        results = [r for r in results if getattr(r, date_filter_field) &lt;= max_date]\n\n    # Return the results\n    return results\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.find","title":"<code>find(entry, tag, find_all=False)</code>","text":"<p>Find the tag in the entry and return the text.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Element</code> <p>The entry to search.</p> required <code>tag</code> <code>str</code> <p>The tag to search for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Union[str, List[str]]</code> <p>The text of the tag.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def find(\n    entry: ElementTree.Element, tag: str, find_all: bool = False\n) -&gt; Union[str, List[str]]:\n    \"\"\"Find the tag in the entry and return the text.\n\n    Args:\n        entry (ElementTree.Element): The entry to search.\n        tag (str): The tag to search for.\n\n    Returns:\n        str: The text of the tag.\n    \"\"\"\n    if not tag.startswith(TAG_PREFIX):\n        tag = TAG_PREFIX + tag\n\n    if find_all:\n        return entry.findall(tag)\n\n    res = entry.find(tag)\n    if res is not None:\n        return res.text\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.format_search_query","title":"<code>format_search_query(title=None, author=None, abstract=None, comment=None, journal_reference=None, category=None, report_number=None, id_list=None, all_=None, how=LogicalOperator.AND, how_list=LogicalOperator.OR)</code>","text":"<p>Format the search query for the Arxiv API.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The title to search for. Defaults to None.</p> <code>None</code> <code>author</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The author to search for. Defaults to None.</p> <code>None</code> <code>abstract</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The abstract to search for. Defaults to None.</p> <code>None</code> <code>comment</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The comment to search for. Defaults to None.</p> <code>None</code> <code>journal_reference</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The journal reference to search for. Defaults to None.</p> <code>None</code> <code>category</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The category to search for. Defaults to None.</p> <code>None</code> <code>report_number</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The report number to search for. Defaults to None.</p> <code>None</code> <code>id_list</code> <code>List[str]</code> <p>List[str], optional, The list of Arxiv IDs to search for. Defaults to None.</p> <code>None</code> <code>all_</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The all field to search for. Defaults to None.</p> <code>None</code> <code>how</code> <code>LogicalOperator</code> <p>LogicalOperator, optional, The logical operator to use when adding the field. Defaults to LogicalOperator.AND.</p> <code>AND</code> <code>how_list</code> <code>LogicalOperator</code> <p>LogicalOperator, optional, The logical operator to use when adding a list of values. Defaults to LogicalOperator.OR.</p> <code>OR</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>str or None: The formatted query string, or None if no fields are provided.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def format_search_query(\n    title: Union[str, List[str]] = None,\n    author: Union[str, List[str]] = None,\n    abstract: Union[str, List[str]] = None,\n    comment: Union[str, List[str]] = None,\n    journal_reference: Union[str, List[str]] = None,\n    category: Union[str, List[str]] = None,\n    report_number: Union[str, List[str]] = None,\n    id_list: List[str] = None,\n    all_: Union[str, List[str]] = None,\n    how: LogicalOperator = LogicalOperator.AND,\n    how_list: LogicalOperator = LogicalOperator.OR,\n) -&gt; Union[str, None]:\n    \"\"\"Format the search query for the Arxiv API.\n\n    Args:\n        title:\n            Union[str, List[str]], optional, The title to search for. Defaults to None.\n        author:\n            Union[str, List[str]], optional, The author to search for. Defaults to None.\n        abstract:\n            Union[str, List[str]], optional, The abstract to search for. Defaults to\n            None.\n        comment:\n            Union[str, List[str]], optional, The comment to search for. Defaults to\n            None.\n        journal_reference:\n            Union[str, List[str]], optional, The journal reference to search for.\n            Defaults to None.\n        category:\n            Union[str, List[str]], optional, The category to search for. Defaults to\n            None.\n        report_number:\n            Union[str, List[str]], optional, The report number to search for.\n            Defaults to None.\n        id_list:\n            List[str], optional, The list of Arxiv IDs to search for. Defaults to None.\n        all_:\n            Union[str, List[str]], optional, The all field to search for. Defaults to\n            None.\n        how:\n            LogicalOperator, optional, The logical operator to use when adding the\n            field. Defaults to LogicalOperator.AND.\n        how_list:\n            LogicalOperator, optional, The logical operator to use when adding a list\n            of values. Defaults to LogicalOperator.OR.\n\n    Returns:\n        str or None: The formatted query string, or None if no fields are provided.\n    \"\"\"\n    # Short-circuit if no fields are provided\n    if all(\n        v is None\n        for v in (\n            title,\n            author,\n            abstract,\n            comment,\n            journal_reference,\n            category,\n            report_number,\n            id_list,\n            all_,\n        )\n    ):\n        return None\n\n    query = \"\"\n\n    for field, value in zip(\n        (\n            SearchField.TITLE,\n            SearchField.AUTHOR,\n            SearchField.ABSTRACT,\n            SearchField.COMMENT,\n            SearchField.JOURNAL_REFERENCE,\n            SearchField.CATEGORY,\n            SearchField.REPORT_NUMBER,\n            SearchField.ID,\n            SearchField.ALL,\n        ),\n        (\n            title,\n            author,\n            abstract,\n            comment,\n            journal_reference,\n            category,\n            report_number,\n            id_list,\n            all_,\n        ),\n    ):\n        if value is not None:\n            query = _extend_query(query, field, value, how=how, how_list=how_list)\n\n    return parse.quote(query, safe=\"/:&amp;=\")\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.get_and_parse","title":"<code>get_and_parse(url, params)</code>","text":"<p>Get and parse the response from the Arxiv API, the payloads are encoded using the Atom 1 XML format.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The endpoint to query</p> required <code>params</code> <code>dict</code> <p>The parameters to pass to the query</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>List[Entry]</code> <p>The parsed response</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def get_and_parse(url: str, params: dict) -&gt; List[Entry]:\n    \"\"\"Get and parse the response from the Arxiv API, the payloads\n    are encoded using the Atom 1 XML format.\n\n    Args:\n        url (str): The endpoint to query\n        params (dict): The parameters to pass to the query\n\n    Returns:\n        dict: The parsed response\n    \"\"\"\n    # Get the response\n    response = SESSION.get(url, params=params)\n\n    # Check for failures\n    if not response.ok:\n        response.raise_for_status()\n\n    # Parse the response securely into ElementTree\n    root = SecureElementTree.fromstring(response.text)\n\n    # TODO finish parsing response into a list of named tuples if no errors,\n    #  otherwise raise the error\n    if len(root) == 1 and root[0].tag == \"error\":\n        raise ValueError(f\"No results found. Error: {root[0].text}\")\n\n    entries = [parse_entry(entry) for entry in find(root, TAG_ENTRY, find_all=True)]\n\n    # Return the parsed response\n    return entries\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.parse_entry","title":"<code>parse_entry(entry)</code>","text":"<p>Parse an entry from the Arxiv API response.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Element</code> <p>The entry to parse.</p> required <p>Returns:</p> Name Type Description <code>Entry</code> <code>Entry</code> <p>The parsed entry.</p> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def parse_entry(entry: ElementTree.Element) -&gt; Entry:\n    \"\"\"Parse an entry from the Arxiv API response.\n\n    Args:\n        entry (ElementTree.Element): The entry to parse.\n\n    Returns:\n        Entry: The parsed entry.\n    \"\"\"\n    # Parse the authors\n    authors = [\n        Author(name=find(author, TAG_NAME), affiliation=find(author, TAG_AFFILIATION))\n        for author in find(entry, TAG_AUTHOR, find_all=True)\n    ]\n\n    # Parse the categories\n    categories = [\n        Category(term=category.attrib[TAG_TERM], scheme=category.attrib[TAG_SCHEME])\n        for category in find(entry, TAG_CATEGORY, find_all=True)\n    ]\n\n    # Parse date-type fields\n    published = find(entry, TAG_PUBLISHED)\n    updated = find(entry, TAG_UPDATED)\n    if published is not None:\n        published = datetime.datetime.fromisoformat(published)\n    if updated is not None:\n        updated = datetime.datetime.fromisoformat(updated)\n\n    # Parse components of the identifier\n    raw_id = find(entry, TAG_ID)\n    id_ = parse_identifier(raw_id)\n\n    # Return the parsed entry\n    return Entry(\n        title=find(entry, TAG_TITLE),\n        id=id_,\n        published=published,\n        updated=updated,\n        summary=find(entry, TAG_SUMMARY),\n        author=authors,\n        category=categories,\n    )\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.parse_identifier","title":"<code>parse_identifier(id_text)</code>","text":"<p>Parse an Arxiv identifier into its components.</p> <p>Parameters:</p> Name Type Description Default <code>id_text</code> <code>str</code> <p>str, the Arxiv identifier to parse.</p> required Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def parse_identifier(id_text: str) -&gt; Identifier:\n    \"\"\"Parse an Arxiv identifier into its components.\n\n    Args:\n        id_text:\n            str, the Arxiv identifier to parse.\n    \"\"\"\n    # Check if the identifier starts with the url prefix, if so remove\n    if id_text.startswith(ID_PREFIX):\n        id_text = id_text[len(ID_PREFIX) :]\n\n    # Check if the identifier is in the new format\n    match = re.match(ID_PATTERN_NEW, id_text)\n    if match:\n        return Identifier(\n            number=match.group(\"number\"),\n            version=match.group(\"version\"),\n            is_new=True,\n        )\n\n    # Check if the identifier is in the old format\n    match = re.match(ID_PATTERN_OLD, id_text)\n    if match:\n        return Identifier(\n            number=match.group(\"number\"),\n            version=None,\n            is_new=False,\n        )\n\n    # If the identifier does not match either pattern, raise an error\n    raise ValueError(f\"Invalid Arxiv identifier: {id_text}\")\n</code></pre>"},{"location":"api/api/arxiv/#sxolar.api.arxiv.query","title":"<code>query(title=None, author=None, abstract=None, comment=None, journal_reference=None, category=None, report_number=None, id_list=None, all_=None, how=LogicalOperator.AND, how_list=LogicalOperator.OR, start=0, max_results=10, sort_by=SortBy.Relevance, sort_order=SortOrder.Descending, min_date=None, max_date=None, date_filter_field=FIELD_ENTRY_UPDATED)</code>","text":"<p>Query the Arxiv API with the given parameters.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The title to search for. Defaults to None.</p> <code>None</code> <code>author</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The author to search for. Defaults to None.</p> <code>None</code> <code>abstract</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The abstract to search for. Defaults to None.</p> <code>None</code> <code>comment</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The comment to search for. Defaults to None.</p> <code>None</code> <code>journal_reference</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The journal reference to search for. Defaults to None.</p> <code>None</code> <code>category</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The category to search for. Defaults to None.</p> <code>None</code> <code>report_number</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The report number to search for. Defaults to None.</p> <code>None</code> <code>id_list</code> <code>List[str]</code> <p>List[str], optional, The list of Arxiv IDs to search for. Defaults to None.</p> <code>None</code> <code>all_</code> <code>Union[str, List[str]]</code> <p>Union[str, List[str]], optional, The all field to search for. Defaults to None.</p> <code>None</code> <code>how</code> <code>LogicalOperator</code> <p>LogicalOperator, optional, The logical operator to use when adding the field. Defaults to LogicalOperator.AND.</p> <code>AND</code> <code>how_list</code> <code>LogicalOperator</code> <p>LogicalOperator, optional, The logical operator to use when adding a list of values. Defaults to LogicalOperator.OR.</p> <code>OR</code> <code>start</code> <code>int</code> <p>int, optional, The index to start the search from. Defaults to 0.</p> <code>0</code> <code>max_results</code> <code>int</code> <p>int, optional, The maximum number of results to return. Defaults to 10.</p> <code>10</code> <code>sort_by</code> <code>SortBy</code> <p>SortBy, optional, The field to sort by. Defaults to SortBy.Relevance.</p> <code>Relevance</code> <code>sort_order</code> <code>SortOrder</code> <p>SortOrder, optional, The order to sort by. Defaults to SortOrder.Descending.</p> <code>Descending</code> Source code in <code>sxolar/api/arxiv.py</code> <pre><code>def query(\n    title: Union[str, List[str]] = None,\n    author: Union[str, List[str]] = None,\n    abstract: Union[str, List[str]] = None,\n    comment: Union[str, List[str]] = None,\n    journal_reference: Union[str, List[str]] = None,\n    category: Union[str, List[str]] = None,\n    report_number: Union[str, List[str]] = None,\n    id_list: List[str] = None,\n    all_: Union[str, List[str]] = None,\n    how: LogicalOperator = LogicalOperator.AND,\n    how_list: LogicalOperator = LogicalOperator.OR,\n    start: int = 0,\n    max_results: int = 10,\n    sort_by: SortBy = SortBy.Relevance,\n    sort_order: SortOrder = SortOrder.Descending,\n    min_date: datetime.datetime = None,\n    max_date: datetime.datetime = None,\n    date_filter_field: str = FIELD_ENTRY_UPDATED,\n) -&gt; List[Entry]:\n    \"\"\"Query the Arxiv API with the given parameters.\n\n    Args:\n        title:\n            Union[str, List[str]], optional, The title to search for. Defaults to None.\n        author:\n            Union[str, List[str]], optional, The author to search for. Defaults to None.\n        abstract:\n            Union[str, List[str]], optional, The abstract to search for. Defaults to\n            None.\n        comment:\n            Union[str, List[str]], optional, The comment to search for. Defaults to\n            None.\n        journal_reference:\n            Union[str, List[str]], optional, The journal reference to search for.\n            Defaults to None.\n        category:\n            Union[str, List[str]], optional, The category to search for. Defaults to\n            None.\n        report_number:\n            Union[str, List[str]], optional, The report number to search for.\n            Defaults to None.\n        id_list:\n            List[str], optional, The list of Arxiv IDs to search for. Defaults to None.\n        all_:\n            Union[str, List[str]], optional, The all field to search for. Defaults to\n            None.\n        how:\n            LogicalOperator, optional, The logical operator to use when adding the\n            field. Defaults to LogicalOperator.AND.\n        how_list:\n            LogicalOperator, optional, The logical operator to use when adding a list\n            of values. Defaults to LogicalOperator.OR.\n        start:\n            int, optional, The index to start the search from. Defaults to 0.\n        max_results:\n            int, optional, The maximum number of results to return. Defaults to 10.\n        sort_by:\n            SortBy, optional, The field to sort by. Defaults to SortBy.Relevance.\n        sort_order:\n            SortOrder, optional, The order to sort by. Defaults to SortOrder.Descending.\n    \"\"\"\n    # Format the search query\n    search_query = format_search_query(\n        title,\n        author,\n        abstract,\n        comment,\n        journal_reference,\n        category,\n        report_number,\n        id_list,\n        all_,\n        how,\n        how_list,\n    )\n\n    # Short-circuit if no search query is provided\n    if search_query is None and id_list is None:\n        raise ValueError(\"No search query provided; cannot query the entire Arxiv.\")\n\n    # Query the API\n    return execute(\n        search_query=search_query,\n        id_list=id_list,\n        start=start,\n        max_results=max_results,\n        sort_by=sort_by,\n        sort_order=sort_order,\n        min_date=min_date,\n        max_date=max_date,\n        date_filter_field=date_filter_field,\n    )\n</code></pre>"},{"location":"api/api/search/","title":"High-Level Interface","text":""},{"location":"api/api/search/#sxolar.api.search","title":"<code>sxolar.api.search</code>","text":"<p>Higher-level api for searching for papers, uses an object interface with overridden magic methods for syntactic sugar</p>"},{"location":"api/api/search/#sxolar.api.search.Abstract","title":"<code>Abstract</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents an abstract query for the arxiv API</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class Abstract(Query):\n    \"\"\"Represents an abstract query for the arxiv API\"\"\"\n\n    def __init__(self, abstract: str):\n        \"\"\"Creates a new abstract query\n\n        Args:\n            abstract:\n                str, the abstract of the paper\n        \"\"\"\n        if not abstract.startswith(SearchField.ABSTRACT):\n            abstract = f\"{SearchField.ABSTRACT}:{abstract}\"\n        super().__init__(abstract)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Abstract.__init__","title":"<code>__init__(abstract)</code>","text":"<p>Creates a new abstract query</p> <p>Parameters:</p> Name Type Description Default <code>abstract</code> <code>str</code> <p>str, the abstract of the paper</p> required Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(self, abstract: str):\n    \"\"\"Creates a new abstract query\n\n    Args:\n        abstract:\n            str, the abstract of the paper\n    \"\"\"\n    if not abstract.startswith(SearchField.ABSTRACT):\n        abstract = f\"{SearchField.ABSTRACT}:{abstract}\"\n    super().__init__(abstract)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.All","title":"<code>All</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents an all query for the arxiv API</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class All(Query):\n    \"\"\"Represents an all query for the arxiv API\"\"\"\n\n    def __init__(self, all_: str):\n        \"\"\"Creates a new all query\n\n        Args:\n            all_:\n                str, the value to search for\n        \"\"\"\n        if not all_.startswith(SearchField.ALL):\n            all_ = f\"{SearchField.ALL}:{all_}\"\n        super().__init__(all_)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.All.__init__","title":"<code>__init__(all_)</code>","text":"<p>Creates a new all query</p> <p>Parameters:</p> Name Type Description Default <code>all_</code> <code>str</code> <p>str, the value to search for</p> required Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(self, all_: str):\n    \"\"\"Creates a new all query\n\n    Args:\n        all_:\n            str, the value to search for\n    \"\"\"\n    if not all_.startswith(SearchField.ALL):\n        all_ = f\"{SearchField.ALL}:{all_}\"\n    super().__init__(all_)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Author","title":"<code>Author</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents an author query for the arxiv API</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class Author(Query):\n    \"\"\"Represents an author query for the arxiv API\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Creates a new author query\n\n        Args:\n            name:\n                str, the name of the author, \"First Last\"\n        \"\"\"\n        if not name.startswith(SearchField.AUTHOR):\n            name = f\"{SearchField.AUTHOR}:{name}\"\n        super().__init__(name)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Author.__init__","title":"<code>__init__(name)</code>","text":"<p>Creates a new author query</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str, the name of the author, \"First Last\"</p> required Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(self, name: str):\n    \"\"\"Creates a new author query\n\n    Args:\n        name:\n            str, the name of the author, \"First Last\"\n    \"\"\"\n    if not name.startswith(SearchField.AUTHOR):\n        name = f\"{SearchField.AUTHOR}:{name}\"\n    super().__init__(name)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Category","title":"<code>Category</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a category query for the arxiv API</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class Category(Query):\n    \"\"\"Represents a category query for the arxiv API\"\"\"\n\n    def __init__(self, category: str):\n        \"\"\"Creates a new category query\n\n        Args:\n            category:\n        \"\"\"\n        if not category.startswith(SearchField.CATEGORY):\n            category = f\"{SearchField.CATEGORY}:{category}\"\n        super().__init__(category)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Category.__init__","title":"<code>__init__(category)</code>","text":"<p>Creates a new category query</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>str</code> required Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(self, category: str):\n    \"\"\"Creates a new category query\n\n    Args:\n        category:\n    \"\"\"\n    if not category.startswith(SearchField.CATEGORY):\n        category = f\"{SearchField.CATEGORY}:{category}\"\n    super().__init__(category)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.JournalRef","title":"<code>JournalRef</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a journal reference query for the arxiv API</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class JournalRef(Query):\n    \"\"\"Represents a journal reference query for the arxiv API\"\"\"\n\n    def __init__(self, journal_ref: str):\n        \"\"\"Creates a new journal reference query\n\n        Args:\n            journal_ref:\n                str, the journal reference\n        \"\"\"\n        if not journal_ref.startswith(SearchField.JOURNAL_REFERENCE):\n            journal_ref = f\"{SearchField.JOURNAL_REFERENCE}:{journal_ref}\"\n        super().__init__(journal_ref)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.JournalRef.__init__","title":"<code>__init__(journal_ref)</code>","text":"<p>Creates a new journal reference query</p> <p>Parameters:</p> Name Type Description Default <code>journal_ref</code> <code>str</code> <p>str, the journal reference</p> required Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(self, journal_ref: str):\n    \"\"\"Creates a new journal reference query\n\n    Args:\n        journal_ref:\n            str, the journal reference\n    \"\"\"\n    if not journal_ref.startswith(SearchField.JOURNAL_REFERENCE):\n        journal_ref = f\"{SearchField.JOURNAL_REFERENCE}:{journal_ref}\"\n    super().__init__(journal_ref)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query","title":"<code>Query</code>","text":"<p>Represents a query clause for the arxiv API</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The value to search for</p> <code>operator</code> <code>str</code> <p>The operator to use</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class Query:\n    \"\"\"Represents a query clause for the arxiv API\n\n    Attributes:\n        value (str): The value to search for\n        operator (str): The operator to use\n    \"\"\"\n\n    def __init__(\n        self,\n        value: str,\n        filter_authors: List[str] = None,\n    ):\n        \"\"\"Creates a new query\n\n        Args:\n            value:\n                str, the value to search for\n            filter_authors:\n                List[str], the authors to filter by\n        \"\"\"\n        self.value = value\n        self.filter_authors = filter_authors or []\n\n    def __str__(self):\n        \"\"\"Returns the string representation of the query\"\"\"\n        return self.value\n\n    def __and__(self, other):\n        \"\"\"Overloads the and operator to create a new query\"\"\"\n        return self.and_(other)\n\n    def __or__(self, other):\n        \"\"\"Overloads the or operator to create a new query\"\"\"\n        return self.or_(other)\n\n    def __sub__(self, other):\n        \"\"\"Overloads the subtraction operator to create a new query\"\"\"\n        return self.and_not(other)\n\n    def and_(self, other: Union[str, \"Query\"]):\n        \"\"\"Join two queries with the AND operator\n\n        Args:\n            other:\n                str, the other query to join with\n\n        Returns:\n            Query: A new query object\n        \"\"\"\n        return Query(\n            f\"{self}{LogicalOperator.AND}{other}\",\n            filter_authors=list(set(self.filter_authors) &amp; set(other.filter_authors)),\n        )\n\n    def and_not(self, other):\n        \"\"\"Join two queries with the AND NOT operator\n\n        Args:\n            other:\n                str, the other query to join with\n\n        Returns:\n            Query: A new query object\n        \"\"\"\n        return Query(\n            f\"{self}{LogicalOperator.AND_NOT}{other}\",\n            filter_authors=list(set(self.filter_authors) - set(other.filter_authors)),\n        )\n\n    def or_(self, other):\n        \"\"\"Join two queries with the OR operator\n\n        Args:\n            other:\n                str, the other query to join with\n\n        Returns:\n            Query: A new query object\n        \"\"\"\n        return Query(\n            f\"{self}{LogicalOperator.OR}{other}\",\n            filter_authors=list(set(self.filter_authors) | set(other.filter_authors)),\n        )\n\n    def join(\n        self, *others: Iterable[\"Query\"], operator: LogicalOperator = LogicalOperator.OR\n    ):\n        \"\"\"Join multiple queries with an operator\n\n        Args:\n            others:\n                Iterable[Query], the queries to join\n            operator:\n                LogicalOperator, the operator to use to join the queries\n\n        Returns:\n            Query: A new query object\n        \"\"\"\n        if not others:\n            return self\n\n        value = self.value\n        authors = set(self.filter_authors)\n        for other in others:\n            value = f\"{value}{operator}{other}\"\n            authors |= set(other.filter_authors)\n\n        return Query(value, filter_authors=list(sorted(authors))).wrap()\n\n    def wrap(self):\n        \"\"\"Wrap the query in parenthesis\n\n        Returns:\n            Query: A new query object\n        \"\"\"\n        return Query(f\"({self})\", filter_authors=self.filter_authors)\n\n    def search(\n        self,\n        start: int = 0,\n        max_results: int = 10,\n        sort_by: SortBy = SortBy.Relevance,\n        sort_order: SortOrder = SortOrder.Descending,\n        min_date: datetime.datetime = None,\n        max_date: datetime.datetime = None,\n        date_filter_field: str = FIELD_ENTRY_UPDATED,\n    ):\n        \"\"\"Searches the arxiv API with the query\n\n        Args:\n            start:\n                int, optional, The starting index of the results\n            max_results:\n                int, optional, The maximum number of results to return\n\n        Returns:\n            list: A list of dictionaries representing the search results\n        \"\"\"\n        results = arxiv.execute(\n            self.value,\n            id_list=None,\n            start=start,\n            max_results=max_results,\n            sort_by=sort_by,\n            sort_order=sort_order,\n            min_date=min_date,\n            max_date=max_date,\n            date_filter_field=date_filter_field,\n        )\n\n        # Apply filter authors if any\n        if self.filter_authors:\n            results = [\n                entry for entry in results if entry.filter_authors(self.filter_authors)\n            ]\n\n        return results\n\n    def to_str(self) -&gt; str:\n        \"\"\"Returns the string representation of the query\"\"\"\n        return self.value\n\n    @staticmethod\n    def from_str(value: str):\n        \"\"\"Creates a new query from a string\n\n        Args:\n            value:\n                str, the value to search for\n        \"\"\"\n        return Query(value)\n\n    @staticmethod\n    def from_authors(*authors: Iterable[str]):\n        \"\"\"Creates a new author query\n\n        Args:\n            authors:\n                str, the name of the author, \"First Last\"\n        \"\"\"\n        authors = [Author(author).wrap() for author in authors]\n        query = authors[0]\n        if authors[1:]:\n            query = query.join(*authors[1:], operator=LogicalOperator.OR)\n        return query\n\n    @staticmethod\n    def from_titles(*titles: Iterable[str]):\n        \"\"\"Creates a new title query\n\n        Args:\n            titles:\n                str, the title of the paper\n        \"\"\"\n        titles = [Title(title) for title in titles]\n        query = titles[0]\n        if titles[1:]:\n            query = query.join(*titles[1:], operator=LogicalOperator.OR)\n        return query\n\n    @staticmethod\n    def from_abstracts(*abstracts: Iterable[str]):\n        \"\"\"Creates a new abstract query\n\n        Args:\n            abstracts:\n                str, the abstract of the paper\n        \"\"\"\n        abstracts = [Abstract(abstract) for abstract in abstracts]\n        query = abstracts[0]\n        if abstracts[1:]:\n            query = query.join(*abstracts[1:], operator=LogicalOperator.OR)\n        return query\n\n    @staticmethod\n    def from_alls(*alls: Iterable[str], operator: LogicalOperator = LogicalOperator.OR):\n        \"\"\"Creates a new all query\n\n        Args:\n            alls:\n                str, the value to search for\n        \"\"\"\n        alls = [All(all_) for all_ in alls]\n        query = alls[0]\n        if alls[1:]:\n            query = query.join(*alls[1:], operator=operator)\n        return query\n\n    @staticmethod\n    def from_journal_refs(*journal_refs: Iterable[str]):\n        \"\"\"Creates a new journal reference query\n\n        Args:\n            journal_refs:\n                str, the journal reference\n        \"\"\"\n        journal_refs = [JournalRef(journal_ref) for journal_ref in journal_refs]\n        query = journal_refs[0]\n        if journal_refs[1:]:\n            query = query.join(*journal_refs[1:], operator=LogicalOperator.OR)\n        return query\n\n    @staticmethod\n    def from_categories(*categories: Iterable[str]):\n        \"\"\"Creates a new category query\n\n        Args:\n            categories:\n                str, the category\n        \"\"\"\n        categories = [Category(category) for category in categories]\n        query = categories[0]\n        if categories[1:]:\n            query = query.join(*categories[1:], operator=LogicalOperator.OR)\n        return query\n\n    @staticmethod\n    def from_combo(\n        authors: Iterable[str] = None,\n        titles: Iterable[str] = None,\n        abstracts: Iterable[str] = None,\n        alls: Iterable[str] = None,\n        journal_refs: Iterable[str] = None,\n        categories: Iterable[str] = None,\n        operator: LogicalOperator = LogicalOperator.AND,\n        filter_authors: bool = False,\n        alls_operator: LogicalOperator = LogicalOperator.OR,\n    ):\n        \"\"\"Creates a new combo query\n\n        Args:\n            authors:\n                Iterable[str], the name of the author, \"First Last\"\n            titles:\n                Iterable[str], the title of the paper\n            abstracts:\n                Iterable[str], the abstract of the paper\n            alls:\n                Iterable[str], the value to search for\n            journal_refs:\n                Iterable[str], the journal reference\n            categories:\n                Iterable[str], the category\n        \"\"\"\n        queries = []\n        if authors:\n            queries.append(Query.from_authors(*authors))\n        if titles:\n            queries.append(Query.from_titles(*titles))\n        if abstracts:\n            queries.append(Query.from_abstracts(*abstracts))\n        if alls:\n            queries.append(Query.from_alls(*alls, operator=alls_operator))\n        if journal_refs:\n            queries.append(Query.from_journal_refs(*journal_refs))\n        if categories:\n            queries.append(Query.from_categories(*categories))\n\n        query = queries[0]\n        if queries[1:]:\n            query = query.join(*queries[1:], operator=operator)\n\n        # Add author filters if needed\n        if filter_authors and authors:\n            query.filter_authors = list(set(authors))\n\n        return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.__and__","title":"<code>__and__(other)</code>","text":"<p>Overloads the and operator to create a new query</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def __and__(self, other):\n    \"\"\"Overloads the and operator to create a new query\"\"\"\n    return self.and_(other)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.__init__","title":"<code>__init__(value, filter_authors=None)</code>","text":"<p>Creates a new query</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>str, the value to search for</p> required <code>filter_authors</code> <code>List[str]</code> <p>List[str], the authors to filter by</p> <code>None</code> Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(\n    self,\n    value: str,\n    filter_authors: List[str] = None,\n):\n    \"\"\"Creates a new query\n\n    Args:\n        value:\n            str, the value to search for\n        filter_authors:\n            List[str], the authors to filter by\n    \"\"\"\n    self.value = value\n    self.filter_authors = filter_authors or []\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.__or__","title":"<code>__or__(other)</code>","text":"<p>Overloads the or operator to create a new query</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def __or__(self, other):\n    \"\"\"Overloads the or operator to create a new query\"\"\"\n    return self.or_(other)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the query</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def __str__(self):\n    \"\"\"Returns the string representation of the query\"\"\"\n    return self.value\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Overloads the subtraction operator to create a new query</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def __sub__(self, other):\n    \"\"\"Overloads the subtraction operator to create a new query\"\"\"\n    return self.and_not(other)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.and_","title":"<code>and_(other)</code>","text":"<p>Join two queries with the AND operator</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Union[str, Query]</code> <p>str, the other query to join with</p> required <p>Returns:</p> Name Type Description <code>Query</code> <p>A new query object</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def and_(self, other: Union[str, \"Query\"]):\n    \"\"\"Join two queries with the AND operator\n\n    Args:\n        other:\n            str, the other query to join with\n\n    Returns:\n        Query: A new query object\n    \"\"\"\n    return Query(\n        f\"{self}{LogicalOperator.AND}{other}\",\n        filter_authors=list(set(self.filter_authors) &amp; set(other.filter_authors)),\n    )\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.and_not","title":"<code>and_not(other)</code>","text":"<p>Join two queries with the AND NOT operator</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>str, the other query to join with</p> required <p>Returns:</p> Name Type Description <code>Query</code> <p>A new query object</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def and_not(self, other):\n    \"\"\"Join two queries with the AND NOT operator\n\n    Args:\n        other:\n            str, the other query to join with\n\n    Returns:\n        Query: A new query object\n    \"\"\"\n    return Query(\n        f\"{self}{LogicalOperator.AND_NOT}{other}\",\n        filter_authors=list(set(self.filter_authors) - set(other.filter_authors)),\n    )\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_abstracts","title":"<code>from_abstracts(*abstracts)</code>  <code>staticmethod</code>","text":"<p>Creates a new abstract query</p> <p>Parameters:</p> Name Type Description Default <code>abstracts</code> <code>Iterable[str]</code> <p>str, the abstract of the paper</p> <code>()</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_abstracts(*abstracts: Iterable[str]):\n    \"\"\"Creates a new abstract query\n\n    Args:\n        abstracts:\n            str, the abstract of the paper\n    \"\"\"\n    abstracts = [Abstract(abstract) for abstract in abstracts]\n    query = abstracts[0]\n    if abstracts[1:]:\n        query = query.join(*abstracts[1:], operator=LogicalOperator.OR)\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_alls","title":"<code>from_alls(*alls, operator=LogicalOperator.OR)</code>  <code>staticmethod</code>","text":"<p>Creates a new all query</p> <p>Parameters:</p> Name Type Description Default <code>alls</code> <code>Iterable[str]</code> <p>str, the value to search for</p> <code>()</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_alls(*alls: Iterable[str], operator: LogicalOperator = LogicalOperator.OR):\n    \"\"\"Creates a new all query\n\n    Args:\n        alls:\n            str, the value to search for\n    \"\"\"\n    alls = [All(all_) for all_ in alls]\n    query = alls[0]\n    if alls[1:]:\n        query = query.join(*alls[1:], operator=operator)\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_authors","title":"<code>from_authors(*authors)</code>  <code>staticmethod</code>","text":"<p>Creates a new author query</p> <p>Parameters:</p> Name Type Description Default <code>authors</code> <code>Iterable[str]</code> <p>str, the name of the author, \"First Last\"</p> <code>()</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_authors(*authors: Iterable[str]):\n    \"\"\"Creates a new author query\n\n    Args:\n        authors:\n            str, the name of the author, \"First Last\"\n    \"\"\"\n    authors = [Author(author).wrap() for author in authors]\n    query = authors[0]\n    if authors[1:]:\n        query = query.join(*authors[1:], operator=LogicalOperator.OR)\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_categories","title":"<code>from_categories(*categories)</code>  <code>staticmethod</code>","text":"<p>Creates a new category query</p> <p>Parameters:</p> Name Type Description Default <code>categories</code> <code>Iterable[str]</code> <p>str, the category</p> <code>()</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_categories(*categories: Iterable[str]):\n    \"\"\"Creates a new category query\n\n    Args:\n        categories:\n            str, the category\n    \"\"\"\n    categories = [Category(category) for category in categories]\n    query = categories[0]\n    if categories[1:]:\n        query = query.join(*categories[1:], operator=LogicalOperator.OR)\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_combo","title":"<code>from_combo(authors=None, titles=None, abstracts=None, alls=None, journal_refs=None, categories=None, operator=LogicalOperator.AND, filter_authors=False, alls_operator=LogicalOperator.OR)</code>  <code>staticmethod</code>","text":"<p>Creates a new combo query</p> <p>Parameters:</p> Name Type Description Default <code>authors</code> <code>Iterable[str]</code> <p>Iterable[str], the name of the author, \"First Last\"</p> <code>None</code> <code>titles</code> <code>Iterable[str]</code> <p>Iterable[str], the title of the paper</p> <code>None</code> <code>abstracts</code> <code>Iterable[str]</code> <p>Iterable[str], the abstract of the paper</p> <code>None</code> <code>alls</code> <code>Iterable[str]</code> <p>Iterable[str], the value to search for</p> <code>None</code> <code>journal_refs</code> <code>Iterable[str]</code> <p>Iterable[str], the journal reference</p> <code>None</code> <code>categories</code> <code>Iterable[str]</code> <p>Iterable[str], the category</p> <code>None</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_combo(\n    authors: Iterable[str] = None,\n    titles: Iterable[str] = None,\n    abstracts: Iterable[str] = None,\n    alls: Iterable[str] = None,\n    journal_refs: Iterable[str] = None,\n    categories: Iterable[str] = None,\n    operator: LogicalOperator = LogicalOperator.AND,\n    filter_authors: bool = False,\n    alls_operator: LogicalOperator = LogicalOperator.OR,\n):\n    \"\"\"Creates a new combo query\n\n    Args:\n        authors:\n            Iterable[str], the name of the author, \"First Last\"\n        titles:\n            Iterable[str], the title of the paper\n        abstracts:\n            Iterable[str], the abstract of the paper\n        alls:\n            Iterable[str], the value to search for\n        journal_refs:\n            Iterable[str], the journal reference\n        categories:\n            Iterable[str], the category\n    \"\"\"\n    queries = []\n    if authors:\n        queries.append(Query.from_authors(*authors))\n    if titles:\n        queries.append(Query.from_titles(*titles))\n    if abstracts:\n        queries.append(Query.from_abstracts(*abstracts))\n    if alls:\n        queries.append(Query.from_alls(*alls, operator=alls_operator))\n    if journal_refs:\n        queries.append(Query.from_journal_refs(*journal_refs))\n    if categories:\n        queries.append(Query.from_categories(*categories))\n\n    query = queries[0]\n    if queries[1:]:\n        query = query.join(*queries[1:], operator=operator)\n\n    # Add author filters if needed\n    if filter_authors and authors:\n        query.filter_authors = list(set(authors))\n\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_journal_refs","title":"<code>from_journal_refs(*journal_refs)</code>  <code>staticmethod</code>","text":"<p>Creates a new journal reference query</p> <p>Parameters:</p> Name Type Description Default <code>journal_refs</code> <code>Iterable[str]</code> <p>str, the journal reference</p> <code>()</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_journal_refs(*journal_refs: Iterable[str]):\n    \"\"\"Creates a new journal reference query\n\n    Args:\n        journal_refs:\n            str, the journal reference\n    \"\"\"\n    journal_refs = [JournalRef(journal_ref) for journal_ref in journal_refs]\n    query = journal_refs[0]\n    if journal_refs[1:]:\n        query = query.join(*journal_refs[1:], operator=LogicalOperator.OR)\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_str","title":"<code>from_str(value)</code>  <code>staticmethod</code>","text":"<p>Creates a new query from a string</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>str, the value to search for</p> required Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_str(value: str):\n    \"\"\"Creates a new query from a string\n\n    Args:\n        value:\n            str, the value to search for\n    \"\"\"\n    return Query(value)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.from_titles","title":"<code>from_titles(*titles)</code>  <code>staticmethod</code>","text":"<p>Creates a new title query</p> <p>Parameters:</p> Name Type Description Default <code>titles</code> <code>Iterable[str]</code> <p>str, the title of the paper</p> <code>()</code> Source code in <code>sxolar/api/search.py</code> <pre><code>@staticmethod\ndef from_titles(*titles: Iterable[str]):\n    \"\"\"Creates a new title query\n\n    Args:\n        titles:\n            str, the title of the paper\n    \"\"\"\n    titles = [Title(title) for title in titles]\n    query = titles[0]\n    if titles[1:]:\n        query = query.join(*titles[1:], operator=LogicalOperator.OR)\n    return query\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.join","title":"<code>join(*others, operator=LogicalOperator.OR)</code>","text":"<p>Join multiple queries with an operator</p> <p>Parameters:</p> Name Type Description Default <code>others</code> <code>Iterable[Query]</code> <p>Iterable[Query], the queries to join</p> <code>()</code> <code>operator</code> <code>LogicalOperator</code> <p>LogicalOperator, the operator to use to join the queries</p> <code>OR</code> <p>Returns:</p> Name Type Description <code>Query</code> <p>A new query object</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def join(\n    self, *others: Iterable[\"Query\"], operator: LogicalOperator = LogicalOperator.OR\n):\n    \"\"\"Join multiple queries with an operator\n\n    Args:\n        others:\n            Iterable[Query], the queries to join\n        operator:\n            LogicalOperator, the operator to use to join the queries\n\n    Returns:\n        Query: A new query object\n    \"\"\"\n    if not others:\n        return self\n\n    value = self.value\n    authors = set(self.filter_authors)\n    for other in others:\n        value = f\"{value}{operator}{other}\"\n        authors |= set(other.filter_authors)\n\n    return Query(value, filter_authors=list(sorted(authors))).wrap()\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.or_","title":"<code>or_(other)</code>","text":"<p>Join two queries with the OR operator</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>str, the other query to join with</p> required <p>Returns:</p> Name Type Description <code>Query</code> <p>A new query object</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def or_(self, other):\n    \"\"\"Join two queries with the OR operator\n\n    Args:\n        other:\n            str, the other query to join with\n\n    Returns:\n        Query: A new query object\n    \"\"\"\n    return Query(\n        f\"{self}{LogicalOperator.OR}{other}\",\n        filter_authors=list(set(self.filter_authors) | set(other.filter_authors)),\n    )\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.search","title":"<code>search(start=0, max_results=10, sort_by=SortBy.Relevance, sort_order=SortOrder.Descending, min_date=None, max_date=None, date_filter_field=FIELD_ENTRY_UPDATED)</code>","text":"<p>Searches the arxiv API with the query</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>int, optional, The starting index of the results</p> <code>0</code> <code>max_results</code> <code>int</code> <p>int, optional, The maximum number of results to return</p> <code>10</code> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of dictionaries representing the search results</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def search(\n    self,\n    start: int = 0,\n    max_results: int = 10,\n    sort_by: SortBy = SortBy.Relevance,\n    sort_order: SortOrder = SortOrder.Descending,\n    min_date: datetime.datetime = None,\n    max_date: datetime.datetime = None,\n    date_filter_field: str = FIELD_ENTRY_UPDATED,\n):\n    \"\"\"Searches the arxiv API with the query\n\n    Args:\n        start:\n            int, optional, The starting index of the results\n        max_results:\n            int, optional, The maximum number of results to return\n\n    Returns:\n        list: A list of dictionaries representing the search results\n    \"\"\"\n    results = arxiv.execute(\n        self.value,\n        id_list=None,\n        start=start,\n        max_results=max_results,\n        sort_by=sort_by,\n        sort_order=sort_order,\n        min_date=min_date,\n        max_date=max_date,\n        date_filter_field=date_filter_field,\n    )\n\n    # Apply filter authors if any\n    if self.filter_authors:\n        results = [\n            entry for entry in results if entry.filter_authors(self.filter_authors)\n        ]\n\n    return results\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.to_str","title":"<code>to_str()</code>","text":"<p>Returns the string representation of the query</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def to_str(self) -&gt; str:\n    \"\"\"Returns the string representation of the query\"\"\"\n    return self.value\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Query.wrap","title":"<code>wrap()</code>","text":"<p>Wrap the query in parenthesis</p> <p>Returns:</p> Name Type Description <code>Query</code> <p>A new query object</p> Source code in <code>sxolar/api/search.py</code> <pre><code>def wrap(self):\n    \"\"\"Wrap the query in parenthesis\n\n    Returns:\n        Query: A new query object\n    \"\"\"\n    return Query(f\"({self})\", filter_authors=self.filter_authors)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Title","title":"<code>Title</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a title query for the arxiv API</p> Source code in <code>sxolar/api/search.py</code> <pre><code>class Title(Query):\n    \"\"\"Represents a title query for the arxiv API\"\"\"\n\n    def __init__(self, title: str):\n        \"\"\"Creates a new title query\n\n        Args:\n            title:\n                str, the title of the paper\n        \"\"\"\n        if not title.startswith(SearchField.TITLE):\n            title = f\"{SearchField.TITLE}:{title}\"\n        super().__init__(title)\n</code></pre>"},{"location":"api/api/search/#sxolar.api.search.Title.__init__","title":"<code>__init__(title)</code>","text":"<p>Creates a new title query</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>str, the title of the paper</p> required Source code in <code>sxolar/api/search.py</code> <pre><code>def __init__(self, title: str):\n    \"\"\"Creates a new title query\n\n    Args:\n        title:\n            str, the title of the paper\n    \"\"\"\n    if not title.startswith(SearchField.TITLE):\n        title = f\"{SearchField.TITLE}:{title}\"\n    super().__init__(title)\n</code></pre>"},{"location":"api/util/gmail/","title":"Google Mail","text":""},{"location":"api/util/gmail/#sxolar.util.gmail","title":"<code>sxolar.util.gmail</code>","text":"<p>Utilities for sending emails using Gmail.</p>"},{"location":"api/util/gmail/#sxolar.util.gmail.send_email","title":"<code>send_email(subject, to, body, from_email=EMAIL_SENDER, safe=True, is_plain=True, app_password=EMAIL_APP_PASSWORD)</code>","text":"<p>Send an email using Gmail.</p> <p>Parameters:</p> Name Type Description Default <code>subject</code> <code>str</code> <p>str, The subject of the email.</p> required <code>to</code> <code>list[str]</code> <p>str, The email address to send the email to.</p> required <code>body</code> <code>str</code> <p>str, The body of the email.</p> required <code>from_email</code> <code>str</code> <p>str, default EMAIL_SENDER, the email address to send the email from.</p> <code>EMAIL_SENDER</code> <code>safe</code> <code>bool</code> <p>bool, default True, whether to suppress exceptions when sending the email.</p> <code>True</code> <code>is_plain</code> <code>bool</code> <p>bool, default True, whether the email is plain text or html.</p> <code>True</code> <code>app_password</code> <code>str</code> <p>str, default EMAIL_APP_PASSWORD, the app password for the Gmail account.</p> <code>EMAIL_APP_PASSWORD</code> Source code in <code>sxolar/util/gmail.py</code> <pre><code>def send_email(\n    subject: str,\n    to: list[str],\n    body: str,\n    from_email: str = EMAIL_SENDER,\n    safe: bool = True,\n    is_plain: bool = True,\n    app_password: str = EMAIL_APP_PASSWORD,\n):\n    \"\"\"Send an email using Gmail.\n\n    Args:\n        subject:\n            str, The subject of the email.\n        to:\n            str, The email address to send the email to.\n        body:\n            str, The body of the email.\n        from_email:\n            str, default EMAIL_SENDER, the email address to send the email from.\n        safe:\n            bool, default True, whether to suppress exceptions when sending the email.\n        is_plain:\n            bool, default True, whether the email is plain text or html.\n        app_password:\n            str, default EMAIL_APP_PASSWORD, the app password for the Gmail account.\n    \"\"\"\n    if app_password is None:\n        raise ValueError(\n            f\"Please set the {EMAIL_APP_PASSWORD_ENV_KEY} environment variable to \"\n            f\"your Gmail app password or specify it as the app_password argument.\"\n        )\n\n    # Create a multipart message and set headers\n    message = MIMEMultipart(\"alternative\")\n    message[\"Subject\"] = subject\n    message[\"From\"] = EMAIL_SENDER\n    message[\"To\"] = \", \".join(to)\n\n    # Check if the email is plain text or html\n    if is_plain:\n        part = MIMEText(body, \"plain\")\n        message.attach(part)\n    else:\n        html_content = f\"\"\"\\\n        &lt;html&gt;\n          &lt;body&gt;\n            {body}\n          &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        # Turn these into MIMEText objects and attach them to the MIMEMultipart message\n        part = MIMEText(html_content, \"html\")\n        message.attach(part)\n\n    # Connect to Gmail's SMTP server and send the email\n    try:\n        # Gmail SMTP server details\n        smtp_server = \"smtp.gmail.com\"\n        smtp_port = 587  # TLS port\n\n        # Establish a secure session using starttls\n        with smtplib.SMTP(smtp_server, smtp_port) as server:\n            server.starttls()\n            server.login(from_email, app_password)\n            server.send_message(message)\n\n    except Exception as e:\n        if safe:\n            print(f\"Error sending email: {e}\")\n        else:\n            raise e\n</code></pre>"},{"location":"tutorials/setup-email/","title":"Tutorial: Setup Email Access","text":"<p>Only for Google Mail</p> <p>This tutorial demonstrates how to set up programmatic email access using App Passwords. Note that nothing in this tutorial is specific to <code>sxolar</code> and can be used with any Python library that requires email access. We include this tutorial here because <code>sxolar</code> can send email summaries of search results.</p>"},{"location":"tutorials/setup-email/#option-1-for-mfa-create-an-app-password","title":"Option 1 (For MFA): Create an App Password","text":"<p>Note that this step is only applicable to accounts that have mutli-factor authentication enabled. If you do not have multi-factor authentication enabled, you can skip this step.</p> <ol> <li>Go to App Passwords.</li> <li>Enter an app name, e.g. \"SampleApp\".</li> <li>Click \"Create\".</li> <li>Copy the generated app password.</li> </ol> <p>The generated app password is a 16-character code that you will use to authenticate your application.</p> <pre><code>App password: \"abcd efgh ijkl mnop\"\n</code></pre>"},{"location":"tutorials/setup-email/#option-2-no-mfa-enable-less-secure-apps","title":"Option 2 (No MFA): Enable Less Secure Apps","text":"<p>If you do not have multi-factor authentication enabled, you can enable access for less secure apps.</p> <ol> <li>Go to Less Secure Apps and turn on access for less secure apps.</li> <li>Go to Display Unlock Captcha and click continue.</li> <li>Go to App Passwords and create a new app password.</li> </ol> <p>Future Deprecation Possible</p> <p>Google has announced that they will be disabling less secure apps in the future. It is also possible that they may deprecate App Passwords in the future. We recommend using the App Password method if you have multi-factor authentication enabled.</p>"},{"location":"tutorials/setup-email/#using-with-sxolar","title":"Using with <code>sxolar</code>","text":"<p>The generated app password can be used with <code>sxolar</code> to send email summaries of search results. You can specify the app password either as a command-line argument or as an environment variable.</p>"},{"location":"tutorials/setup-email/#command-line-argument","title":"Command-Line Argument","text":"<p>When using the <code>sxolar summary</code> command, you can specify the app password using the <code>--email-password</code> option.</p> <pre><code>sxolar summary ... --gmail-app-password \"abcd efgh ijkl mnop\"\n</code></pre>"},{"location":"tutorials/setup-email/#environment-variable","title":"Environment Variable","text":"<p>You can also set the app password as an environment variable. The <code>sxolar</code> package checks for the specific environment variable <code>SXOLAR_EMAIL_APP_PASSWORD</code> to get the app password.</p> <pre><code>export SXOLAR_EMAIL_APP_PASSWORD=\"abcd efgh ijkl mnop\"\n</code></pre> <p>Then you can use the <code>sxolar summary</code> command without specifying the app password.</p> <pre><code>sxolar summary ...\n</code></pre>"},{"location":"tutorials/setup-periodic/","title":"Tutorial: Setup Periodic Search","text":"<p>This tutorial demonstrates how to set up periodic searches using the <code>sxolar</code> library. Periodic searches allow users to automatically retrieve search results at regular intervals and receive email summaries of the results. This feature is useful for staying up-to-date with the latest research in a specific field or topic.</p> <p>Prerequisites</p> <p>Before proceeding with this tutorial, make sure you have a GitHub account, have set up email  access using the instructions in the Setup Email Access tutorial. Further, this tutorial assumes  that you have a configuration file with the desired search queries. If you do not have a configuration file, refer  to the Simple Summary or Config Files tutorials for more  information.</p>"},{"location":"tutorials/setup-periodic/#create-new-github-repository","title":"Create New GitHub Repository","text":"<p>To set up periodic searches, we will create a new GitHub repository to store the configuration file and other related files. We will use GitHub Actions to trigger the periodic searches and send email summaries of the search results for free.</p> <ol> <li>Go to GitHub and log in to your account.</li> <li>Click on the \"+\" icon in the top right corner and select \"New repository\".</li> <li>Enter a name for the repository, e.g., <code>sxolar-searches</code>.</li> <li>Add a description if desired.</li> <li>Choose whether the repository should be public or private.</li> <li>Click on \"Create repository\".</li> <li>Clone the repository to your local machine using the following command:</li> </ol> <pre><code>git clone  \n</code></pre>"},{"location":"tutorials/setup-periodic/#shortcut-use-template-repository","title":"Shortcut: Use Template Repository","text":"<p>If you prefer, you can use the sxolar-template-run repository as a template to set up periodic searches. This repository contains a pre-configured GitHub Actions workflow that triggers periodic searches and sends email summaries of the search results. You can customize the configuration file and other settings as needed.</p>"},{"location":"tutorials/setup-periodic/#add-configuration-file","title":"Add Configuration File","text":"<p>Next, we will add the configuration file with the desired search queries to the GitHub repository. The configuration file should be in the YAML format and contain the search queries that you want to run periodically.</p> <p>Example configuration file (<code>config.yaml</code>):</p> <pre><code>GWaves:\n  - name: \"LIGO / VIRGO Papers Past Month\"\n    authors: [\n      \"The LIGO Scientific Collaboration\",\n      \"The Virgo Collaboration\",\n    ]\n    filter_authors: True\n    # Set the maximum number of results to 1000 to ensure we\n    # get a large enough sample of papers such that some are\n    # from the past 4 weeks\n    max_results: 1000\n    trailing:\n      num: 4\n      unit: \"weeks\"\n</code></pre>"},{"location":"tutorials/setup-periodic/#set-up-github-actions-workflow","title":"Set Up GitHub Actions Workflow","text":"<p>To trigger periodic searches and send email summaries of the search results, we will create a GitHub Actions workflow in the repository. The workflow will run the search queries defined in the configuration file at regular intervals and send email summaries of the search results using the <code>sxolar</code> library.</p> <p>The workflow will need to do the following:</p> <ol> <li>Install the <code>sxolar</code> library.</li> <li>Run the search queries defined in the configuration file.</li> <li>Send email summaries of the search results.</li> </ol> <p>Thanks to the command line api of <code>sxolar</code>, we can combine the steps 2 and 3 into a single command. The below is an example of a GitHub Actions workflow that triggers periodic searches and sends email summaries of the search results:</p> <pre><code>name: Example Sxolar Run\non:\n  # Uncomment the below to also run on pushes, as a way to test\n  #  push:\n  #      branches:\n  #      - main\n  schedule:\n    # Run Weekly on Sunday at 8am EST (1pm UTC)\n    # For more detail on cron syntax, see https://crontab.guru/\n    - cron: '0 13 * * 0'\n\njobs:\n  MySummary:\n    # Setup the minimal environment: linux and python 3.11\n    name: UNIX Build (${{ matrix.python-version }}, ${{ matrix.os }})\n    runs-on: ${{ matrix.os }}\n    defaults:\n      run:\n        shell: bash -l {0}\n    strategy:\n      fail-fast: false\n      max-parallel: 4\n      matrix:\n        os: [ \"ubuntu-latest\" ]\n        python-version: [ \"3.11\" ]\n\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      # Install the necessary dependencies (sxolar)\n      - name: Install sxolar\n        run: |\n          pip install sxolar\n\n      # Run the summary using the command line and config file\n      - name: Run GWaves\n        run: |\n          sxolar summary --config configs/gwaves.yml \\\n            --name GWaves \\\n            --email-to myrecipient@gmail.com \\\n            --email-from myemail@gmail.com \\\n            --email-subject \"Sxolar Weekly Digest: GWwaves\" \\\n            --gmail-app-password \"${{ secrets.SXOLARGMAILAPPPASSWORD }}\" \\\n            --output email\n</code></pre>"},{"location":"tutorials/simple-query/","title":"Tutorial: Simple Query","text":"<p>This tutorial demonstrates how to use the <code>sxolar</code> library to search for arXiv entries based on a query. We will cover the basic usage of the <code>sxolar</code> library and show how to search for arXiv entries using various criteria such as the title, author, abstract, and publication date.</p> <p>In this tutorial we want to search arXiv for entries related to quantum computing. We will search for entries that have \"quantum computing\" in the title and display the top 5 results.</p>"},{"location":"tutorials/simple-query/#installation","title":"Installation","text":"<p>If you have already installed the <code>sxolar</code> library, you can skip this step. Otherwise, you can install the library using <code>pip</code> by running the following command:</p> <pre><code>pip install sxolar\n</code></pre>"},{"location":"tutorials/simple-query/#basic-query","title":"Basic Query","text":"<p>To search for arXiv entries based on a query, you can use the <code>sxolar.Query</code> api. The <code>sxolar.Query</code> class provides a simple way to construct a query and retrieve search results.</p> <p>Here is an example of how to search for arXiv entries related to quantum computing:</p> <pre><code>from sxolar import Title\n\n# Create a query object\nquery = Title(\"quantum computing\")\n\n# Execute the query and display the top 5 results\nresults = query.search(max_results=5)\n\n# Display the search results\nfor result in results:\n    print(result.title)\n    print(result.author)\n    print(result.summary)\n    print()\n</code></pre> <p>In this example, we create a <code>Title</code> query object with the search term \"quantum computing\". We then execute the query and display the top 5 results. The search results include the title, authors, and abstract of each entry.</p> <p>You can customize the query by specifying additional search criteria such as author, abstract, and publication date.</p>"},{"location":"tutorials/simple-query/#advanced-query","title":"Advanced Query","text":"<p>You can construct more complex queries by combining multiple search criteria. For example, you can search for entries related to quantum computing that were authored by a specific author and published within a specific time frame.</p> <p>Here is an example of a more complex query:</p> <pre><code>import datetime\nfrom sxolar import Title, Author\n\n# Create a query object with multiple search criteria\nquery = Title(\"quantum computing\")\nquery &amp;= (Author(\"John Doe\") | Author(\"Jane Smith\")).wrap()\n\n# Execute the query and display the top 5 results\nresults = query.search(\n    max_results=5,\n    min_date=datetime.datetime(2022, 1, 1, tzinfo=datetime.UTC),\n    max_date=datetime.datetime(2022, 12, 31, tzinfo=datetime.UTC),\n)\n\n# Display the search results\nfor result in results:\n    print(result.title)\n    print(result.author)\n    print(result.summary)\n    print()\n</code></pre> <p>In this example, we create a <code>Title</code> query object with the search term \"quantum computing\" and an <code>Author</code> query object with the author names \"John Doe\" and \"Jane Smith\". We then combine the two query objects using logical operators to create a complex query. We also specify the publication date range for the search results.</p>"},{"location":"tutorials/simple-query/#conclusion","title":"Conclusion","text":"<p>This tutorial has demonstrated how to use the <code>sxolar</code> library to search for arXiv entries based on a query. You can construct simple or complex queries by specifying various search criteria and logical combinations. The <code>sxolar</code> library provides a user-friendly interface for searching and retrieving arXiv entries, making it easy to find relevant research papers on arXiv.</p>"},{"location":"tutorials/simple-summary/","title":"Tutorial: Simple Summary","text":"<p>This tutorial demonstrates how to generate a simple summary of search results using the <code>sxolar</code> library. Summaries provide a concise overview of search results, including key metadata such as titles, authors, and abstracts. Users can customize the content and format of summaries to suit their needs, making it easier to review and analyze search results. We first begin by setting up a configuration file that details the structure of the summary. Each summary is a collection of sections, where each section represents a specific search query. Each section can have a title, author, abstract, and other search criteria. The configuration file is a YAML file that specifies the named summaries and their corresponding sections.</p>"},{"location":"tutorials/simple-summary/#installation","title":"Installation","text":"<p>If you have already installed the <code>sxolar</code> library, you can skip this step. Otherwise, you can install the library using <code>pip</code> by running the following command:</p> <pre><code>pip install sxolar\n</code></pre>"},{"location":"tutorials/simple-summary/#configuration-file","title":"Configuration File","text":"<p>To generate a summary, you need to create a configuration file that specifies the structure of the summary. The configuration file should be in the YAML format and contain the named summaries and their corresponding sections. Each section can include search criteria such as title, author, abstract, and other metadata fields.</p> <p>Example configuration file (<code>summary.yaml</code>):</p> <pre><code>summary name 1:\n  - name: \"Section 1: Topic A x Authors 1, 2 | Recent 2 Weeks\"\n    authors: [\"Author 1\", \"Author 2\"]\n    alls: [\"Topic A\"]\n    trailing:\n      num: 14\n      unit: \"days\"\n\n  - name: \"Section 2: Topic B x Authors 3, 4 | Recent 2 Months\"\n    authors: [\"Author 3\", \"Author 4\"]\n    alls: [\"Topic B\"]\n    trailing:\n      num: 2\n      unit: \"months\"\n\nsummary name 2:\n  - name: \"Section 1: Topic C x Authors 5, 6\"\n    authors: [\"Author 5\", \"Author 6\"]\n    alls: [\"Topic C\"]\n</code></pre> <p>In the above example, we define two named summaries, each with multiple sections. Each section specifies the search criteria for the summary, including the title, authors, and other metadata fields. The <code>trailing</code> field specifies the time frame for the search results, such as the past 2 weeks or 2 months.</p>"},{"location":"tutorials/simple-summary/#generate-summary","title":"Generate Summary","text":"<p>Once you have created the configuration file, you can generate a summary using the <code>sxolar</code> library. The  summary can be generated using the python library or the command line.</p>"},{"location":"tutorials/simple-summary/#python-library","title":"Python Library","text":"<p>To generate a summary using the <code>sxolar</code> library, you can use the <code>sxolar.Config</code> class to read and parse the <code>Summary</code> objects. Then the <code>Summary</code> objects can be used to generate the content summary.</p> <p>Here is an example of how to generate a summary using the <code>sxolar</code> library: This example will use the summary file contained in the repo at <code>./sample.yml</code>.</p> <pre><code>from sxolar import Config, Summary\n\n# Load the configuration file, this will also parse the summary objects\nconfig = Config(\"summary.yaml\")\n\n# Get the summary object for \"summary name 1\"\ns1 = config.summaries(\"summary name 1\")\nassert isinstance(s1, Summary)\n\n# Generate the summary first by refreshing the query\ns1.refresh()\n\n# Print the summary (plain)\nprint(s1.to_text())\n\n# Print the summary (html, usually for email)\nprint(s1.to_html())\n</code></pre>"},{"location":"user-guide/command-line/","title":"Using <code>sxolar</code> from the Command Line","text":"<p>The <code>sxolar</code> library can be used from the command line to search for arXiv entries and display the results in a user-friendly format. This section provides an overview of how to use <code>sxolar</code> from the command line, including the available options and usage examples.</p>"},{"location":"user-guide/command-line/#installation","title":"Installation","text":"<p>The command-line interface for <code>sxolar</code> is automatically installed when you install the <code>sxolar</code> library using <code>pip</code>. If you haven't installed <code>sxolar</code> yet, you can do so by running the following command:</p> <pre><code>pip install sxolar\n</code></pre>"},{"location":"user-guide/command-line/#usage","title":"Usage","text":"<p>The <code>sxolar</code> command-line interface provides a simple way to search for arXiv entries based on various criteria. There are presently the following commands available:</p> <ul> <li><code>sxolar query</code>: Search for arXiv entries based on a query.</li> <li><code>sxolar summary</code>: Display a human-readable summary of an arXiv search.</li> </ul>"},{"location":"user-guide/command-line/#sxolar-query","title":"<code>sxolar query</code>","text":"<p>The <code>sxolar query</code> command allows you to search for arXiv entries based on a query. You can specify various search criteria such as the title, author, abstract, and publication date. Here is an example of how to use the <code>sxolar search</code></p> <pre><code>sxolar search --title \"quantum computing\" --max-results 5\n</code></pre> <p>In this example, we search for arXiv entries related to quantum computing and specify that we want a maximum of 5 results. The next example shows more complicated usage of the <code>sxolar search</code> command:</p> <pre><code>sxolar search --title \"quantum computing\" \\\n  --author \"John Doe\" \\\n  --author \"Jane Smith\" \\\n  --trailing 100 \\\n  --max-results 50\n</code></pre> <p>In this example, we search for arXiv entries related to quantum computing that were authored by either John Doe or Jane Smith, and we specify that we want a maximum of 50 results. We also use the <code>--trailing</code> option to search for entries that were published in the last 100 days.</p> <p>Post-Filtering and Increasing <code>max-results</code></p> <p>The <code>--trailing</code> option specifies the number of days from the current date to search for entries. For example, <code>--trailing 100</code> searches for entries published in the last 100 days. Because this filter occurs after the search  results are retrieved, it may decrease the number of results returned. In such cases, it is currently recommended  to increase the number of results, you can use the <code>--max-results</code> option.</p>"},{"location":"user-guide/command-line/#sxolar-summary","title":"<code>sxolar summary</code>","text":"<p>The <code>sxolar summary</code> command allows you to display a human-readable summary of an arXiv search. You can specify the search criteria and the number of results to display. </p> <p>Summaries Require Config Files</p> <p>The <code>sxolar summary</code> command requires a configuration file. The configuration file is a YAML file that specifies the a set of named summaries. Each summary is a collection of sections, where each section is a formatted query. Each section / query can have a title, author, abstract, and other search criteria. More detail on the format of the configuration file can be found in the Configuration Files docs.</p> <p>Here is an example of how to use the <code>sxolar summary</code> command:</p> <pre><code>sxolar summary --config-file config.yaml --name MySummary\n</code></pre> <p>In this example, we display a summary of the search summary named <code>MySummary</code> from the configuration file <code>config.yaml</code>. This configuration file should contain the search criteria for the query. An acceptable config file for the example above would look like this:</p> <pre><code>MySummary:\n  - name: \"Section 1\"\n    authors: [\"Author A\", \"Author B\"]\n    alls: [\"Topic X\"]\n</code></pre> <p>This configuration file specifies a summary named <code>MySummary</code> with one section named <code>Section 1</code>. The section searches for entries with authors <code>Author A</code> or <code>Author B</code> and topics <code>Topic X</code>.</p>"},{"location":"user-guide/concepts/","title":"Key Concepts","text":"<p>The <code>sxolar</code> library provides two main interfaces for interacting with the arXiv API: a low-level interface and a high-level interface. These interfaces are designed to cater to different user needs and preferences, offering varying levels of control and abstraction. Throughout, there are core concepts that drive the design and functionality of the <code>sxolar</code> library. These concepts are essential to understanding how the library works and how to use it effectively. This page provides an overview of the key concepts that underpin the <code>sxolar</code> library, including search queries, search results, and entry objects. Understanding these concepts will help you navigate the library's documentation and use its features effectively.</p>"},{"location":"user-guide/concepts/#arxiv-api","title":"ArXiv API","text":"<p>The <code>sxolar</code> library interacts with the arXiv API to search for and retrieve arXiv entries. The arXiv API is a web-based interface that allows users to access the arXiv repository programmatically. It provides a range of search and retrieval capabilities, enabling users to find arXiv entries based on various criteria such as title, author, abstract, and publication date. The <code>sxolar</code> library abstracts away the complexities of interacting with the arXiv API, providing a user-friendly interface for searching and retrieving arXiv entries.</p>"},{"location":"user-guide/concepts/#search-structure-fields-and-operators","title":"Search Structure: Fields and Operators","text":"<p>The arXiv API uses a structured query language to search for entries in the arXiv repository. This query language allows users to specify search criteria and logical combinations to filter the results.</p> <p>Each query is composed of one or more fields, such as title, author, abstract, and category.  Search fields are combined with logical operators like <code>AND</code>, <code>OR</code>, and <code>NOT</code>.  By constructing valid search queries, users can retrieve specific subsets of arXiv entries that match their criteria. For more detail on the arxiv API, see the arXiv API documentation.</p> <p>The <code>sxolar</code> library provides classes and functions that help users construct valid search queries and submit them to the arXiv API. By leveraging these abstractions, users can easily create complex search queries without needing to understand the underlying query language of the arXiv API.</p>"},{"location":"user-guide/concepts/#data-structure-entries","title":"Data Structure: Entries","text":"<p>The primary data structure internal to arXiv is the entry object. An entry object represents a single arXiv entry and contains metadata such as the title, authors, abstract, publication date, and other relevant information. When searching for arXiv entries, the arXiv API returns a collection of entries (formatted in XML) that match  the search criteria to the best of its ability. </p> <p>The <code>sxolar</code> library parses these XML entries into Python objects.</p>"},{"location":"user-guide/concepts/#search-results-and-limitations","title":"Search Results and Limitations","text":"<p>When a search query is submitted to the arXiv API, the API returns a list of entries that match the search criteria.  These entries are considered search results and are represented as a collection of entry objects. The number of search results returned by the API may be limited by the API itself, and users can specify the maximum number of results they want to retrieve.</p> <p>Often, the search results include entries that are not directly related to the search query but are considered  relevant by the arXiv API. <code>sxolar</code> provides methods to filter and sort search results based on user-defined criteria, but this sorting is done after the search results are retrieved from the API. For example,  users can post-filter search results based on publication date, and exact author name matches.</p>"},{"location":"user-guide/concepts/#summaries-and-sections","title":"Summaries and Sections","text":"<p>The <code>sxolar</code> library provides a range of features to help users interact with arXiv entries more effectively. One such feature is the ability to generate human-readable summaries of search results. Summaries provide a concise overview of the search results, including key metadata such as titles, authors, and abstracts. Users can customize the content and format of summaries to suit their needs, making it easier to review and analyze search results.</p> <p>A <code>Summary</code> is a collection of <code>Section</code> objects, each of which represents a specific configured query. Query configuration and summary configuration can be stored in YAML formatted files. This allows <code>sxolar</code> to server as a persisted search tool, where users can save and re-run complex search queries. For more information on summaries and sections, see the Configuration Files documentation.</p>"},{"location":"user-guide/config-files/","title":"Configuration Files","text":"<p>The <code>sxolar</code> command-line interface provides a simple way to search for arXiv entries based on various criteria. The <code>sxolar summary</code> command allows you to display a human-readable summary of an arXiv search. The <code>sxolar summary</code> command requires a configuration file. The configuration file is a YAML file that specifies a set of named queries. Each query can have a title, author, abstract, and other search criteria.</p>"},{"location":"user-guide/config-files/#structure-of-configuration-files","title":"Structure of Configuration Files","text":"<p>Configuration files for <code>sxolar</code> are structured as follows:</p> <ul> <li>Each configuration file is a YAML file.</li> <li>The top-level keys in the YAML file are the names of the Summaries.</li> <li>Each Summary is a collection of Sections.</li> <li>Each Section is a collection of name and search criteria.</li> </ul>"},{"location":"user-guide/config-files/#examples","title":"Examples","text":"<p>Here are some examples of configuration files for <code>sxolar</code>.</p>"},{"location":"user-guide/config-files/#simple-configuration-file","title":"Simple Configuration File","text":"<p>Here is an example of a simple configuration file:</p> <pre><code>MySummary:\n  - name: \"Section 1: John and Jane\"\n    authors: [\n      \"John Doe\",\n      \"Jane Smith\",\n    ]\n    max_results: 5\n\n  - name: \"Section 2: Quantum Computing\"\n    titles: [\n      \"quantum computing\",\n    ]\n    max_results: 5\n</code></pre> <p>Note that the configuration file specifies a summary named <code>MySummary</code> with two sections. The first section is named <code>Section 1: John and Jane</code> and searches for entries authored by \"John Doe\" and \"Jane Smith\". The second section is named <code>Section 2: Quantum Computing</code> and searches for entries with the title \"quantum computing\".</p>"},{"location":"user-guide/config-files/#advanced-configuration-file","title":"Advanced Configuration File","text":"<p>Here is an example of a simple configuration file:</p> <pre><code>MySummary2:\n  - name: \"Section 1: John and Jane Recent\"\n    authors: [\n      \"John Doe\",\n      \"Jane Smith\",\n    ]\n    max_results: 50\n    trailing:\n      num: 4\n      unit: \"weeks\"\n\n  - name: \"Section 2: Quantum Computing &amp; Multiverse\"\n    titles: [\n      \"quantum computing\",\n    ]\n    alls: [\n      \"multiverse\",\n      \"many worlds\",\n    ]\n    alls_operator: \" OR \"\n    max_results: 10\n</code></pre> <p>In this example, the configuration file specifies a summary named <code>MySummary2</code> with two sections. The first section is named <code>Section 1: John and Jane Recent</code> and searches for entries authored by \"John Doe\" and \"Jane Smith\" within the last 4 weeks. The second section is named <code>Section 2: Quantum Computing &amp; Multiverse</code> and searches for entries with the title \"quantum computing\" and either \"multiverse\" or \"many worlds\" in any search field.</p>"},{"location":"user-guide/high-level/","title":"High-Level <code>sxolar</code> Interface","text":"<p>The high-level interface of <code>sxolar</code> provides a more simplified way to interact with the  arXiv API. This interface is built on top of the low-level interface and  provides a more user-friendly way to search for and retrieve arXiv entries. The high-level  interface is designed to be easy to use and requires minimal knowledge of the arXiv API.</p> <p>The high-level interface is essentially an object-oriented wrapper around the low-level interface, providing a more intuitive way to specify search criteria and retrieve arXiv entries. Search components are created as objects and combined using builtin logical operators to create complex search queries. </p>"},{"location":"user-guide/high-level/#core-components","title":"Core Components","text":"<p>The high-level interface consists of several core components and methods:</p> <ul> <li><code>Query</code>: A class that represents a search query for arXiv entries.      This class is a base class that accepts a fully formatted query. Field-specific subclasses     provide a more object-oriented, user-friendly way to specify search criteria and logical     combinations.<ul> <li><code>Title</code>: A subclass of <code>Query</code> that represents the title field of an arXiv entry.</li> <li><code>Author</code>: A subclass of <code>Query</code> that represents the author field of an arXiv entry.</li> <li><code>Abstract</code>: A subclass of <code>Query</code> that represents the abstract field of an arXiv entry.</li> <li><code>Category</code>: A subclass of <code>Query</code> that represents the category field of an arXiv entry.</li> <li><code>JournalRef</code>: A subclass of <code>Query</code> that represents the journal reference field of an arXiv entry.</li> <li><code>All</code>: A subclass of <code>Query</code> that represents all fields of an arXiv entry.</li> </ul> </li> <li><code>Query.search</code>: A method that submits the search query to the arXiv API and returns a list      of <code>Entry</code> objects that match the query. This method accepts arguments for sorting, maximum results,     and date filtering of results.</li> </ul>"},{"location":"user-guide/high-level/#example-usage","title":"Example Usage","text":"<p>Here is an example of how to use the high-level interface to search for arXiv entries:</p> <pre><code>from sxolar.api.search import Title\n\n# Create a search query for arXiv entries related to quantum computing\nquery = Title('quantum computing')\n\n# Submit the search query and retrieve the results\nentries = query.search(max_results=5)\n\nfor entry in entries:\n    print(entry.title)\n    print(entry.author)\n    print(entry.summary)\n</code></pre> <p>In this example, we create a search query for arXiv entries related to quantum computing using the <code>Title</code> class. We specify that we want a maximum of 5 results and then iterate over the results to print out the title, authors,  and summary of each entry.</p> <p>The high-level interface provides a more user-friendly way to interact with the arXiv API, allowing users to search for and retrieve arXiv entries based on a wide range of criteria. This next example shows a more complex search query:</p> <pre><code>import datetime\nfrom sxolar.api.search import Title, Author\n\n# Create a search query for arXiv entries related to quantum computing that were \n# published by either of two authors: John Doe or Jane Smith in 2021\nquery = Title('quantum computing') \nquery &amp;= (Author('John Doe') | Author('Jane Smith')).wrap()\n\n# Submit the search query and retrieve the results\nentries = query.search(min_date=datetime.datetime(2021, 1, 1, tzinfo=datetime.UTC), \n                       max_date=datetime.datetime(2021, 12, 31, tzinfo=datetime.UTC),\n                       max_results=5)\n\nfor entry in entries:\n    print(entry.title)\n    print(entry.author)\n    print(entry.summary)\n</code></pre> <p>In this example, we create a search query for arXiv entries related to quantum computing that were published by either of two authors, John Doe or Jane Smith, in 2021. We specify that we want a maximum of 5 results and then iterate over the results to print out the title, authors, and summary of each entry. The high-level interface allows for complex search queries to be constructed using logical operators and field-specific classes. Note that in this example, we use the <code>wrap</code> method to group the author queries together using parentheses to ensure the correct logical combination.</p>"},{"location":"user-guide/low-level/","title":"Low-Level <code>sxolar</code> Interface","text":"<p>Since the arXiv service provides a RESTful API, it is possible to interact with the arXiv service programmatically. <code>sXolar</code> provides a low-level interface to the arXiv API, which allows users to interact with the arXiv service  in a more natural way. At its core, the low-level interface is a set of functions that allow users to format search query strings, submit search queries to arXiv in accordance with api constraints,  and extract useful information from search results.</p> <p>The low-level interface of sXolar provides a more direct way to interact with the arXiv API. This interface is more flexible than the high-level interface, but requires more knowledge of the arXiv API. The low-level interface is built from scratch and incorporates the latest features of the arXiv API. The low-level interface is designed to be as user-friendly as possible, while still providing access to the full functionality of the arXiv API.</p>"},{"location":"user-guide/low-level/#core-components","title":"Core Components","text":"<p>The low-level interface consists of several core components:</p> <ul> <li><code>format_search_query</code>: A function that takes pythonic      user inputs and formats them into a valid arXiv search query string. This function can accept     information related to all search fields, including the title, author, abstract, and more.      Further, it can also accept information related to the logical operators, such as <code>AND</code>, <code>OR</code>, and <code>NOT</code>,     when combining multiple search fields.</li> <li><code>Entry</code>: Represents an arXiv entry, and is the primary     object returned by the low-level interface. It has attributes for all the metadata      of an arXiv entry, including the title, authors, abstract, and more.</li> <li><code>execute</code>: A function that takes a formatted search query string and submits     it to the arXiv API. This function returns a list of <code>Entry</code> objects, each of which     represents an arXiv entry that matches the search query.</li> <li><code>query</code>: A function that combines the functionality of <code>format_search_query</code> and <code>execute</code>.     This function takes pythonic user inputs, formats them into a valid arXiv search query string, and submits the query     to the arXiv API. This function returns a list of <code>Entry</code> objects, each of which represents     an arXiv entry that matches the search query.</li> </ul>"},{"location":"user-guide/low-level/#example-usage","title":"Example Usage","text":"<p>Here is an example of how to use the low-level interface to search for arXiv entries:</p> <pre><code>from sxolar.api.arxiv import query\n\n# Search for arXiv entries related to quantum computing\nentries = query(title='quantum computing', max_results=5)\n\nfor entry in entries:\n    print(entry.title)\n    print(entry.author)\n    print(entry.summary)\n</code></pre> <p>In this example, we use the <code>query</code> function to search for arXiv entries related to quantum computing. We specify that we want a maximum of 5 results, and then iterate over the results to print out the title, authors, and summary of each entry.</p> <p>The low-level interface provides a powerful and flexible way to interact with the arXiv API, allowing users to search  for and retrieve arXiv entries based on a wide range of criteria. This next example shows a more complex search query:</p> <pre><code>import datetime\nfrom sxolar.api.arxiv import query\n\n# Search for arXiv entries related to quantum computing that were published in 2021\nentries = query(\n    title='quantum computing', \n    min_date=datetime.datetime(2021, 1, 1, tzinfo=datetime.UTC),\n    max_date=datetime.datetime(2021, 12, 31, tzinfo=datetime.UTC),\n    max_results=5,\n)\n\nfor entry in entries:\n    print(entry.title)\n    print(entry.author)\n    print(entry.summary)\n</code></pre> <p>Max Results</p> <p>The <code>max_results</code> parameter specifies the maximum number of results to return from the arxiv search query. However, the <code>sxolar</code> package can impose additional filters on the results after they have been returned from arxiv, leading to fewer results than specified by <code>max_results</code>. This is because the raw arxiv search  results often contain duplicates or entries that do not meet the criteria specified by the user. In the example above, we specify that we want a maximum of 5 results, but the actual number of results returned may be less than 5, since we are also filtering out entries that were not published in 2021. Future versions of the package may provide more control over this behavior.</p>"}]}